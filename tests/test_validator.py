# Copyright 2025 Ralph Lemke
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tests for AFL semantic validator."""

import pytest

from afl import parse
from afl.validator import AFLValidator, ValidationError, ValidationResult, validate


@pytest.fixture
def validator():
    """Create a validator instance."""
    return AFLValidator()


class TestNameUniqueness:
    """Test name uniqueness validation."""

    def test_duplicate_facet_names(self, validator):
        """Duplicate facet names should error."""
        ast = parse("""
        facet User(name: String)
        facet User(email: String)
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Duplicate facet name 'User'" in str(e) for e in result.errors)

    def test_duplicate_workflow_names(self, validator):
        """Duplicate workflow names should error."""
        ast = parse("""
        workflow Process(input: String)
        workflow Process(data: String)
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Duplicate workflow name 'Process'" in str(e) for e in result.errors)

    def test_duplicate_event_facet_names(self, validator):
        """Duplicate event facet names should error."""
        ast = parse("""
        event facet Handler(input: String)
        event facet Handler(data: String)
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Duplicate event facet name 'Handler'" in str(e) for e in result.errors)

    def test_facet_workflow_same_name(self, validator):
        """Facet and workflow with same name should error."""
        ast = parse("""
        facet Process(input: String)
        workflow Process(input: String)
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Duplicate" in str(e) and "Process" in str(e) for e in result.errors)

    def test_unique_names_valid(self, validator):
        """Unique names should pass."""
        ast = parse("""
        facet User(name: String)
        facet Account(id: String)
        workflow Process(input: String)
        """)
        result = validator.validate(ast)
        assert result.is_valid

    def test_duplicate_names_in_namespace(self, validator):
        """Duplicate names within a namespace should error."""
        ast = parse("""
        namespace team.data {
            facet User(name: String)
            facet User(email: String)
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Duplicate facet name 'User'" in str(e) for e in result.errors)

    def test_same_name_different_namespaces(self, validator):
        """Same name in different namespaces should be valid."""
        ast = parse("""
        namespace team.a {
            facet User(name: String)
        }
        namespace team.b {
            facet User(email: String)
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid

    def test_duplicate_step_names(self, validator):
        """Duplicate step names within a block should error."""
        ast = parse("""
        facet Data(value: String) => (result: String)
        workflow Test(input: String) => (output: String) andThen {
            step1 = Data(value = $.input)
            step1 = Data(value = $.input)
            yield Test(output = step1.result)
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Duplicate step name 'step1'" in str(e) for e in result.errors)

    def test_unique_step_names_valid(self, validator):
        """Unique step names should pass."""
        ast = parse("""
        facet Data(value: String) => (result: String)
        workflow Test(input: String) => (output: String) andThen {
            step1 = Data(value = $.input)
            step2 = Data(value = $.input)
            yield Test(output = step2.result)
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid


class TestStepReferences:
    """Test step reference validation."""

    def test_valid_input_reference(self, validator):
        """Valid $.param reference should pass."""
        ast = parse("""
        facet Data(value: String) => (result: String)
        workflow Test(input: String) => (output: String) andThen {
            step1 = Data(value = $.input)
            yield Test(output = step1.result)
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid

    def test_invalid_input_reference(self, validator):
        """Invalid $.param reference should error."""
        ast = parse("""
        facet Data(value: String) => (result: String)
        workflow Test(input: String) => (output: String) andThen {
            step1 = Data(value = $.nonexistent)
            yield Test(output = step1.result)
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Invalid input reference '$.nonexistent'" in str(e) for e in result.errors)

    def test_valid_step_reference(self, validator):
        """Valid step.attr reference should pass."""
        ast = parse("""
        facet Data(value: String) => (result: String)
        workflow Test(input: String) => (output: String) andThen {
            step1 = Data(value = $.input)
            step2 = Data(value = step1.result)
            yield Test(output = step2.result)
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid

    def test_invalid_step_attribute(self, validator):
        """Invalid step attribute should error."""
        ast = parse("""
        facet Data(value: String) => (result: String)
        workflow Test(input: String) => (output: String) andThen {
            step1 = Data(value = $.input)
            step2 = Data(value = step1.nonexistent)
            yield Test(output = step2.result)
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any(
            "Invalid attribute 'nonexistent' for step 'step1'" in str(e) for e in result.errors
        )

    def test_reference_undefined_step(self, validator):
        """Reference to undefined step should error."""
        ast = parse("""
        facet Data(value: String) => (result: String)
        workflow Test(input: String) => (output: String) andThen {
            step1 = Data(value = undefined.result)
            yield Test(output = step1.result)
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Reference to undefined step 'undefined'" in str(e) for e in result.errors)

    def test_reference_step_defined_after(self, validator):
        """Reference to step defined after should error."""
        ast = parse("""
        facet Data(value: String) => (result: String)
        workflow Test(input: String) => (output: String) andThen {
            step1 = Data(value = step2.result)
            step2 = Data(value = $.input)
            yield Test(output = step2.result)
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        # Step2 is not defined when step1 tries to reference it
        assert any("undefined step 'step2'" in str(e) for e in result.errors)

    def test_foreach_variable_valid(self, validator):
        """Foreach variable reference should be valid."""
        ast = parse("""
        facet Process(item: String) => (result: String)
        workflow Test(items: Json) => (results: Json) andThen foreach item in $.items {
            step1 = Process(item = item.value)
            yield Test(results = step1.result)
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid


class TestYieldValidation:
    """Test yield statement validation."""

    def test_valid_yield_containing_facet(self, validator):
        """Yield to containing facet should pass."""
        ast = parse("""
        facet Data(value: String) => (result: String)
        workflow Test(input: String) => (output: String) andThen {
            step1 = Data(value = $.input)
            yield Test(output = step1.result)
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid

    def test_invalid_yield_target(self, validator):
        """Yield to wrong facet should error."""
        ast = parse("""
        facet Data(value: String) => (result: String)
        workflow Test(input: String) => (output: String) andThen {
            step1 = Data(value = $.input)
            yield WrongFacet(output = step1.result)
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Invalid yield target 'WrongFacet'" in str(e) for e in result.errors)

    def test_yield_to_mixin_valid(self, validator):
        """Yield to mixin should pass."""
        ast = parse("""
        facet Data(value: String) => (result: String)
        facet Extra(data: String) => (extra: String)
        workflow Test(input: String) => (output: String) with Extra(data = "x") andThen {
            step1 = Data(value = $.input)
            yield Test(output = step1.result)
            yield Extra(extra = step1.result)
        }
        """)
        result = validator.validate(ast)
        # This should pass - yields to both containing facet and mixin
        assert result.is_valid

    def test_yield_references_validated(self, validator):
        """References in yield should be validated."""
        ast = parse("""
        facet Data(value: String) => (result: String)
        workflow Test(input: String) => (output: String) andThen {
            step1 = Data(value = $.input)
            yield Test(output = undefined.result)
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Reference to undefined step 'undefined'" in str(e) for e in result.errors)

    def test_duplicate_yield_targets(self, validator):
        """Duplicate yield targets should error."""
        ast = parse("""
        facet Data(value: String) => (result: String)
        workflow Test(input: String) => (output: String) andThen {
            step1 = Data(value = $.input)
            yield Test(output = step1.result)
            yield Test(output = step1.result)
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Duplicate yield target 'Test'" in str(e) for e in result.errors)


class TestConvenienceFunction:
    """Test module-level validate function."""

    def test_validate_function(self):
        """Test validate() convenience function."""
        ast = parse("facet Test()")
        result = validate(ast)
        assert isinstance(result, ValidationResult)
        assert result.is_valid

    def test_validate_with_errors(self):
        """Test validate() returns errors."""
        ast = parse("""
        facet Test()
        facet Test()
        """)
        result = validate(ast)
        assert not result.is_valid
        assert len(result.errors) > 0


class TestValidationResult:
    """Test ValidationResult class."""

    def test_empty_result_is_valid(self):
        """Empty result should be valid."""
        result = ValidationResult()
        assert result.is_valid
        assert len(result.errors) == 0

    def test_result_with_errors_invalid(self):
        """Result with errors should be invalid."""
        result = ValidationResult()
        result.add_error("Test error")
        assert not result.is_valid
        assert len(result.errors) == 1

    def test_error_string_format(self):
        """Error should format with location."""
        error = ValidationError("Test error", line=10, column=5)
        assert "Test error at line 10, column 5" == str(error)

    def test_error_string_no_location(self):
        """Error without location should format correctly."""
        error = ValidationError("Test error")
        assert "Test error" == str(error)


class TestComplexScenarios:
    """Test complex validation scenarios."""

    def test_nested_block_references(self, validator):
        """References in nested contexts should work."""
        ast = parse("""
        facet Transform(input: String) => (output: String)
        facet Process(data: String) => (result: String)

        workflow Pipeline(input: String) => (final: String) andThen {
            t1 = Transform(input = $.input)
            p1 = Process(data = t1.output)
            yield Pipeline(final = p1.result)
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid

    def test_multiple_errors_reported(self, validator):
        """Multiple errors should all be reported."""
        ast = parse("""
        facet Data(value: String) => (result: String)
        facet Data(other: String)
        workflow Test(input: String) => (output: String) andThen {
            step1 = Data(value = $.nonexistent)
            step1 = Data(value = $.input)
            yield WrongTarget(output = step1.result)
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        # Should have multiple errors: duplicate name, invalid input ref, duplicate step, invalid yield
        assert len(result.errors) >= 3

    def test_full_namespace_example(self, validator):
        """Full namespace example should validate correctly."""
        ast = parse("""
        namespace team.email {
            facet EmailConfig(host: String, port: Int)
            facet SendResult(messageId: String) => (status: String)

            event facet SendEmail(to: String, subject: String) => (messageId: String)

            workflow BulkSend(recipients: Json, template: String) => (results: Json) andThen foreach r in $.recipients {
                email = SendEmail(to = r.email, subject = $.template)
                yield BulkSend(results = email.messageId)
            }
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid


class TestUseStatementValidation:
    """Test use statement validation."""

    def test_valid_use_statement(self, validator):
        """Use statement referencing existing namespace should pass."""
        ast = parse("""
        namespace common.utils {
            facet Helper(value: String)
        }
        namespace app.main {
            use common.utils
            facet App(input: String)
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid

    def test_invalid_use_statement(self, validator):
        """Use statement referencing non-existent namespace should error."""
        ast = parse("""
        namespace app.main {
            use nonexistent.namespace
            facet App(input: String)
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any(
            "namespace 'nonexistent.namespace' does not exist" in str(e) for e in result.errors
        )

    def test_multiple_valid_use_statements(self, validator):
        """Multiple use statements referencing existing namespaces should pass."""
        ast = parse("""
        namespace lib.a {
            facet FacetA(value: String)
        }
        namespace lib.b {
            facet FacetB(value: String)
        }
        namespace app {
            use lib.a
            use lib.b
            facet App(input: String)
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid

    def test_mixed_valid_invalid_use_statements(self, validator):
        """Mix of valid and invalid use statements should report errors."""
        ast = parse("""
        namespace lib.a {
            facet FacetA(value: String)
        }
        namespace app {
            use lib.a
            use lib.nonexistent
            facet App(input: String)
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("namespace 'lib.nonexistent' does not exist" in str(e) for e in result.errors)


class TestFacetNameResolution:
    """Test facet name resolution and ambiguity detection."""

    def test_unambiguous_facet_reference(self, validator):
        """Unambiguous facet reference should pass."""
        ast = parse("""
        namespace lib {
            facet Helper(value: String) => (result: String)
        }
        namespace app {
            use lib
            facet App(input: String) => (output: String) andThen {
                h = Helper(value = $.input)
                yield App(output = h.result)
            }
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid

    def test_ambiguous_facet_reference(self, validator):
        """Ambiguous facet reference should error."""
        ast = parse("""
        namespace a.b {
            facet SomeFacet(input: String) => (result: String)
        }
        namespace c.d {
            facet SomeFacet(input: String) => (result: String)
        }
        namespace app {
            use a.b
            use c.d
            facet App(input: String) => (output: String) andThen {
                s = SomeFacet(input = $.input)
                yield App(output = s.result)
            }
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Ambiguous facet reference 'SomeFacet'" in str(e) for e in result.errors)

    def test_qualified_name_resolves_ambiguity(self, validator):
        """Using fully qualified name should resolve ambiguity."""
        ast = parse("""
        namespace a.b {
            facet SomeFacet(input: String) => (result: String)
        }
        namespace c.d {
            facet SomeFacet(input: String) => (result: String)
        }
        namespace app {
            use a.b
            use c.d
            facet App(input: String) => (output: String) andThen {
                s = a.b.SomeFacet(input = $.input)
                yield App(output = s.result)
            }
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid

    def test_local_facet_takes_precedence(self, validator):
        """Facet in current namespace takes precedence over imports."""
        ast = parse("""
        namespace lib {
            facet Helper(value: String) => (result: String)
        }
        namespace app {
            use lib
            facet Helper(value: String) => (result: String)
            facet App(input: String) => (output: String) andThen {
                h = Helper(value = $.input)
                yield App(output = h.result)
            }
        }
        """)
        result = validator.validate(ast)
        # Local Helper should be used without ambiguity
        assert result.is_valid

    def test_mixin_with_qualified_name(self, validator):
        """Mixin with qualified name should work."""
        ast = parse("""
        namespace a.b {
            facet SomeFacet(input: String) => (data: String)
        }
        namespace c.d {
            facet SomeFacet(input: String) => (data: String)
            facet OtherFacet(value: String) with a.b.SomeFacet(input = "test")
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid

    def test_unknown_qualified_facet(self, validator):
        """Unknown fully qualified facet should error."""
        ast = parse("""
        namespace app {
            facet App(input: String) => (output: String) andThen {
                s = nonexistent.namespace.Facet(input = $.input)
                yield App(output = s.result)
            }
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Unknown facet 'nonexistent.namespace.Facet'" in str(e) for e in result.errors)


class TestSchemaValidation:
    """Test schema declaration validation."""

    def test_duplicate_schema_names(self, validator):
        """Duplicate schema names in namespace should error."""
        ast = parse("""
        namespace app {
            schema User {
                name: String
            }
            schema User {
                email: String
            }
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Duplicate schema name 'User'" in str(e) for e in result.errors)

    def test_schema_facet_same_name(self, validator):
        """Schema and facet with same name should error."""
        ast = parse("""
        namespace app {
            schema User {
                name: String
            }
            facet User(name: String)
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Duplicate" in str(e) and "User" in str(e) for e in result.errors)

    def test_duplicate_field_names(self, validator):
        """Duplicate field names within a schema should error."""
        ast = parse("""
        namespace app {
            schema User {
                name: String,
                name: Int
            }
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Duplicate schema field name 'name'" in str(e) for e in result.errors)

    def test_valid_schema(self, validator):
        """Valid schema should pass validation."""
        ast = parse("""
        namespace app {
            schema User {
                name: String,
                age: Int
            }
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid

    def test_duplicate_schema_in_namespace(self, validator):
        """Duplicate schema names in namespace should error."""
        ast = parse("""
        namespace app {
            schema Config {
                key: String
            }
            schema Config {
                value: String
            }
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Duplicate schema name 'Config'" in str(e) for e in result.errors)

    def test_schema_and_facet_same_name_in_namespace(self, validator):
        """Schema and facet with same name in namespace should error."""
        ast = parse("""
        namespace app {
            schema Data {
                value: String
            }
            facet Data(value: String)
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Duplicate" in str(e) and "Data" in str(e) for e in result.errors)


class TestAmbiguousReferences:
    """Test ambiguous facet references across namespaces and imports."""

    def test_ambiguous_across_imports_and_toplevel(self, validator):
        """Facet defined both at top-level and in imported namespace is ambiguous."""
        ast = parse("""
        facet Helper(value: String) => (result: String)

        namespace lib {
            facet Helper(value: String) => (result: String)
        }

        namespace app {
            use lib
            workflow Run(input: String) => (output: String) andThen {
                h = Helper(value = $.input)
                yield Run(output = h.result)
            }
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Ambiguous" in str(e) for e in result.errors)

    def test_ambiguous_multiple_global_namespaces(self, validator):
        """Facet defined in two non-imported namespaces should be ambiguous when referenced from third."""
        ast = parse("""
        namespace x {
            facet Shared(a: String) => (r: String)
        }
        namespace y {
            facet Shared(a: String) => (r: String)
        }
        namespace app {
            use x
            use y
            workflow Run(input: String) => (output: String) andThen {
                s = Shared(a = $.input)
                yield Run(output = s.r)
            }
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Ambiguous facet reference 'Shared'" in str(e) for e in result.errors)


class TestForwardStepReferences:
    """Test that forward references to later steps are rejected."""

    def test_step2_references_step3_forward(self, validator):
        """A step cannot reference a step defined after it."""
        ast = parse("""
        facet Data(value: String) => (result: String)
        workflow Test(input: String) => (output: String) andThen {
            step1 = Data(value = $.input)
            step2 = Data(value = step3.result)
            step3 = Data(value = $.input)
            yield Test(output = step3.result)
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("undefined step 'step3'" in str(e) for e in result.errors)


class TestEventFacetValidation:
    """Test event facet with body and mixin references."""

    def test_event_facet_with_body(self, validator):
        """Event facet with andThen body should validate correctly."""
        ast = parse("""
        facet Compute(x: Int) => (result: Int)
        event facet Process(input: Int) => (output: Int) andThen {
            c = Compute(x = $.input)
            yield Process(output = c.result)
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid

    def test_event_facet_mixin_references(self, validator):
        """Event facet with mixin references should validate."""
        ast = parse("""
        facet Retry(maxAttempts: Int)
        event facet Process(input: String) => (result: String) with Retry(maxAttempts = 3)
        """)
        result = validator.validate(ast)
        assert result.is_valid

    def test_event_facet_invalid_mixin(self, validator):
        """Event facet with unknown mixin should produce an error."""
        ast = parse("""
        event facet Process(input: String) with nonexistent.ns.Mixin(x = "y")
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Unknown facet" in str(e) for e in result.errors)


class TestScriptBlockValidation:
    """Test script block validation."""

    def test_script_block_valid(self, validator):
        """Valid script block passes validation."""
        ast = parse('facet Test() script "x = 1"')
        result = validator.validate(ast)
        assert result.is_valid

    def test_script_block_empty_code(self, validator):
        """Script block with empty code should fail."""
        ast = parse('facet Test() script ""')
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("must contain code" in str(e) for e in result.errors)

    def test_script_block_whitespace_only(self, validator):
        """Script block with only whitespace should fail."""
        ast = parse('facet Test() script "   "')
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("must contain code" in str(e) for e in result.errors)

    def test_script_block_event_facet(self, validator):
        """Event facet with script block validates."""
        ast = parse('event facet Process() script "result = {}"')
        result = validator.validate(ast)
        assert result.is_valid

    def test_script_block_with_params(self, validator):
        """Script block with params validates."""
        ast = parse(r'facet Transform(x: String) => (y: String) script "result[\"y\"] = params[\"x\"]"')
        result = validator.validate(ast)
        assert result.is_valid


class TestPromptBlockValidation:
    """Test prompt block validation."""

    def test_prompt_block_valid(self, validator):
        """Valid prompt block passes validation."""
        ast = parse('''event facet Test(x: String) => (y: String)
prompt {
    system "System prompt"
    template "Process {x}"
    model "claude"
}''')
        result = validator.validate(ast)
        assert result.is_valid

    def test_prompt_block_missing_template(self, validator):
        """Prompt block without template should fail."""
        ast = parse('''event facet Test(x: String)
prompt {
    system "Only system"
}''')
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("template" in str(e) for e in result.errors)

    def test_prompt_block_invalid_placeholder(self, validator):
        """Prompt block with invalid placeholder should fail."""
        ast = parse('''event facet Test(x: String)
prompt {
    template "Value is {invalid_param}"
}''')
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("invalid_param" in str(e) for e in result.errors)

    def test_prompt_block_valid_placeholder(self, validator):
        """Prompt block with valid placeholder should pass."""
        ast = parse('''event facet Test(myParam: String)
prompt {
    template "Value is {myParam}"
}''')
        result = validator.validate(ast)
        assert result.is_valid

    def test_prompt_block_multiple_placeholders(self, validator):
        """Prompt block can use multiple placeholders."""
        ast = parse('''event facet Test(a: String, b: String, c: Int)
prompt {
    template "{a} and {b} make {c}"
}''')
        result = validator.validate(ast)
        assert result.is_valid

    def test_prompt_block_placeholder_in_system(self, validator):
        """Placeholders in system prompt are also validated."""
        ast = parse('''event facet Test(role: String)
prompt {
    system "You are a {role}."
    template "Do something"
}''')
        result = validator.validate(ast)
        assert result.is_valid

    def test_prompt_block_invalid_placeholder_in_system(self, validator):
        """Invalid placeholder in system prompt should fail."""
        ast = parse('''event facet Test(x: String)
prompt {
    system "You are a {undefined_role}."
    template "{x}"
}''')
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("undefined_role" in str(e) for e in result.errors)

    def test_prompt_block_in_namespace(self, validator):
        """Prompt block inside namespace is validated."""
        ast = parse('''namespace ns {
    event facet Query(q: String) => (answer: String)
    prompt {
        template "Question: {q}"
    }
}''')
        result = validator.validate(ast)
        assert result.is_valid


class TestErrorLocation:
    """Test that validation errors include location information."""

    def test_error_line_only(self):
        """Error with line but no column."""
        from afl.validator import ValidationError

        error = ValidationError("test error", line=5)
        assert "at line 5" in str(error)
        assert "column" not in str(error)

    def test_add_error_with_location(self, validator):
        """add_error with SourceLocation should capture line/column."""
        from afl.ast import SourceLocation
        from afl.validator import ValidationResult

        result = ValidationResult()
        loc = SourceLocation(line=10, column=3)
        result.add_error("test", loc)
        assert result.errors[0].line == 10
        assert result.errors[0].column == 3

    def test_add_error_without_location(self, validator):
        """add_error without location should have None line/column."""
        from afl.validator import ValidationResult

        result = ValidationResult()
        result.add_error("test")
        assert result.errors[0].line is None
        assert result.errors[0].column is None


class TestMixinCallValidation:
    """Test that mixin call references in step calls are validated."""

    def test_mixin_args_reference_validated(self, validator):
        """References in mixin call arguments should be validated."""
        ast = parse("""
        facet Config(setting: String)
        facet Process(input: String) => (result: String)
        workflow Test(x: String) => (output: String) andThen {
            p = Process(input = $.x) with Config(setting = $.nonexistent)
            yield Test(output = p.result)
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Invalid input reference '$.nonexistent'" in str(e) for e in result.errors)


class TestSchemaInstantiation:
    """Test schema instantiation validation in step statements."""

    def test_valid_schema_instantiation(self, validator):
        """Valid schema instantiation should pass."""
        ast = parse("""
        namespace app {
            schema Config {
                timeout: Long,
                retries: Long
            }
            event facet DoSomething(config: Config) => (result: String)
            workflow Example() => (output: String) andThen {
                cfg = Config(timeout = 30, retries = 3)
                result = DoSomething(config = cfg.timeout)
                yield Example(output = result.result)
            }
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid, [str(e) for e in result.errors]

    def test_schema_field_reference(self, validator):
        """Step referencing schema fields should pass."""
        ast = parse("""
        namespace app {
            schema Data {
                value: String,
                count: Long
            }
            facet Process(input: String) => (output: String)
            workflow Test(x: String) => (result: String) andThen {
                d = Data(value = $.x, count = 5)
                p = Process(input = d.value)
                yield Test(result = p.output)
            }
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid, [str(e) for e in result.errors]

    def test_invalid_schema_field_reference(self, validator):
        """Reference to nonexistent schema field should error."""
        ast = parse("""
        namespace app {
            schema Data {
                value: String
            }
            facet Process(input: String) => (output: String)
            workflow Test(x: String) => (result: String) andThen {
                d = Data(value = $.x)
                p = Process(input = d.nonexistent)
                yield Test(result = p.output)
            }
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Invalid attribute 'nonexistent' for step 'd'" in str(e) for e in result.errors)

    def test_unknown_schema_field(self, validator):
        """Unknown field in schema instantiation should error."""
        ast = parse("""
        namespace app {
            schema Config {
                timeout: Long
            }
            workflow Test() andThen {
                cfg = Config(timeout = 30, unknown = "bad")
            }
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Unknown field 'unknown' for schema 'Config'" in str(e) for e in result.errors)

    def test_schema_with_mixins_error(self, validator):
        """Schema instantiation with mixins should error."""
        ast = parse("""
        namespace app {
            schema Config {
                timeout: Long
            }
            facet SomeMixin()
            workflow Test() andThen {
                cfg = Config(timeout = 30) with SomeMixin()
            }
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("cannot have mixins" in str(e) for e in result.errors)

    def test_namespaced_schema_instantiation(self, validator):
        """Namespaced schema instantiation should work."""
        ast = parse("""
        namespace app {
            schema Settings {
                name: String,
                value: Long
            }
            facet Process(s: Settings) => (result: String)
            workflow Test(input: String) => (output: String) andThen {
                s = Settings(name = $.input, value = 42)
                r = Process(s = s.name)
                yield Test(output = r.result)
            }
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid, [str(e) for e in result.errors]

    def test_qualified_namespaced_schema_instantiation(self, validator):
        """Qualified schema reference should work across namespaces."""
        ast = parse("""
        namespace lib {
            schema Config {
                key: String
            }
        }
        namespace app {
            use lib
            workflow Run(input: String) => (output: String) andThen {
                c = Config(key = $.input)
                yield Run(output = c.key)
            }
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid, [str(e) for e in result.errors]

    def test_schema_with_concat_expression(self, validator):
        """Schema instantiation with concatenation expression should validate."""
        ast = parse("""
        namespace app {
            schema Data {
                combined: String
            }
            workflow Test(a: String, b: String) => (result: String) andThen {
                d = Data(combined = $.a ++ $.b)
                yield Test(result = d.combined)
            }
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid, [str(e) for e in result.errors]

    def test_schema_fields_accessible_after_step(self, validator):
        """Schema fields should be accessible in subsequent steps."""
        ast = parse("""
        namespace app {
            schema Request {
                url: String,
                method: String
            }
            facet Fetch(url: String, method: String) => (data: String)
            workflow Test(input: String) => (result: String) andThen {
                req = Request(url = $.input, method = "GET")
                resp = Fetch(url = req.url, method = req.method)
                yield Test(result = resp.data)
            }
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid, [str(e) for e in result.errors]


class TestBinaryExprValidation:
    """Test validation of BinaryExpr in references."""

    def test_valid_refs_in_binary(self, validator):
        """Valid references in binary expressions pass."""
        ast = parse("""
        facet Value(input: Long) => (output: Long)
        workflow Test(a: Long) => (output: Long) andThen {
            s = Value(input = $.a + 1)
            yield Test(output = s.output)
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid, [str(e) for e in result.errors]

    def test_invalid_input_ref_in_binary(self, validator):
        """Invalid input reference in binary expr should error."""
        ast = parse("""
        facet Value(input: Long) => (output: Long)
        workflow Test(a: Long) => (output: Long) andThen {
            s = Value(input = $.nonexistent + 1)
            yield Test(output = s.output)
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("nonexistent" in str(e) for e in result.errors)

    def test_invalid_step_ref_in_binary(self, validator):
        """Invalid step reference in binary expr should error."""
        ast = parse("""
        facet Value(input: Long) => (output: Long)
        workflow Test(a: Long) => (output: Long) andThen {
            s = Value(input = unknown.output + 1)
            yield Test(output = s.output)
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("unknown" in str(e) for e in result.errors)

    def test_nested_binary_in_concat(self, validator):
        """References in binary inside concat should be validated."""
        ast = parse("""
        facet Value(input: Long) => (output: Long)
        workflow Test(a: Long, b: Long) => (output: String) andThen {
            s = Value(input = $.a + $.b)
            yield Test(output = s.output ++ s.output)
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid, [str(e) for e in result.errors]

    def test_step_ref_binary_chain(self, validator):
        """Chain of arithmetic with step refs should validate."""
        ast = parse("""
        facet Value(input: Long) => (output: Long)
        workflow Test(input: Long) => (output: Long) andThen {
            s1 = Value(input = $.input + 1)
            s2 = Value(input = s1.output + 1)
            yield Test(output = s2.output + 1)
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid, [str(e) for e in result.errors]


class TestMultipleBlockValidation:
    """Test validation of multiple andThen blocks."""

    def test_valid_multi_block(self, validator):
        """Multiple andThen blocks with valid refs should pass."""
        ast = parse("""
        facet V(input: Long) => (output: Long)
        workflow Test(input: Long) => (a: Long, b: Long) andThen {
                s1 = V(input = $.input)
                yield Test(a = s1.output)
            } andThen {
                s2 = V(input = $.input)
                yield Test(b = s2.output)
            }
        """)
        result = validator.validate(ast)
        assert result.is_valid, [str(e) for e in result.errors]

    def test_same_step_names_across_blocks(self, validator):
        """Same step names in different blocks should pass (independent scopes)."""
        ast = parse("""
        facet V(input: Long) => (output: Long)
        workflow Test(input: Long) => (a: Long, b: Long) andThen {
                s = V(input = $.input)
                yield Test(a = s.output)
            } andThen {
                s = V(input = $.input)
                yield Test(b = s.output)
            }
        """)
        result = validator.validate(ast)
        assert result.is_valid, [str(e) for e in result.errors]

    def test_invalid_ref_in_second_block(self, validator):
        """Invalid reference in second block should error."""
        ast = parse("""
        facet V(input: Long) => (output: Long)
        workflow Test(input: Long) => (a: Long, b: Long) andThen {
                s1 = V(input = $.input)
                yield Test(a = s1.output)
            } andThen {
                s2 = V(input = $.nonexistent)
                yield Test(b = s2.output)
            }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("nonexistent" in str(e) for e in result.errors)


class TestCollectionLiteralValidation:
    """Test validation of references inside collection literals."""

    def test_valid_refs_in_array(self, validator):
        """Valid references inside array should pass."""
        ast = parse("""
        facet V(items: String) => (output: Long)
        workflow Test(x: Long) andThen {
            s = V(items = "test")
            s2 = V(items = [$.x, s.output])
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid, [str(e) for e in result.errors]

    def test_invalid_input_ref_in_array(self, validator):
        """Invalid input reference inside array should error."""
        ast = parse("""
        facet V(items: String)
        workflow Test(x: Long) andThen {
            s = V(items = [$.nonexistent])
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("nonexistent" in str(e) for e in result.errors)

    def test_invalid_step_ref_in_array(self, validator):
        """Invalid step reference inside array should error."""
        ast = parse("""
        facet V(items: String)
        workflow Test(x: Long) andThen {
            s = V(items = [missing.output])
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("missing" in str(e) for e in result.errors)

    def test_valid_refs_in_map(self, validator):
        """Valid references inside map should pass."""
        ast = parse("""
        facet V(config: String) => (output: Long)
        workflow Test(x: Long) andThen {
            s = V(config = "test")
            s2 = V(config = #{"a": $.x, "b": s.output})
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid, [str(e) for e in result.errors]

    def test_invalid_ref_in_map_value(self, validator):
        """Invalid reference in map value should error."""
        ast = parse("""
        facet V(config: String)
        workflow Test(x: Long) andThen {
            s = V(config = #{"a": $.missing})
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("missing" in str(e) for e in result.errors)

    def test_valid_refs_in_index_expr(self, validator):
        """Valid references in index expression should pass."""
        ast = parse("""
        facet V(items: String) => (output: String)
        workflow Test(idx: Long) andThen {
            s = V(items = "test")
            s2 = V(items = s.output[$.idx])
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid, [str(e) for e in result.errors]

    def test_nested_collections_validation(self, validator):
        """Nested collections with valid references should pass."""
        ast = parse("""
        facet V(items: String) => (output: Long)
        workflow Test(x: Long) andThen {
            s = V(items = "test")
            s2 = V(items = [[$.x], [s.output]])
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid, [str(e) for e in result.errors]


class TestExpressionTypeChecking:
    """Test expression type checking in the validator."""

    def test_string_plus_int_error(self, validator):
        """String + Int should produce type error."""
        ast = parse("""
        facet V(x: Long)
        workflow Test() andThen {
            s = V(x = "hello" + 1)
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("String" in str(e) and "arithmetic" in str(e) for e in result.errors)

    def test_int_plus_string_error(self, validator):
        """Int + String should produce type error."""
        ast = parse("""
        facet V(x: Long)
        workflow Test() andThen {
            s = V(x = 1 + "hello")
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("String" in str(e) and "arithmetic" in str(e) for e in result.errors)

    def test_int_plus_int_valid(self, validator):
        """Int + Int should be valid."""
        ast = parse("""
        facet V(x: Long)
        workflow Test() andThen {
            s = V(x = 1 + 2)
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid, [str(e) for e in result.errors]

    def test_int_multiply_int_valid(self, validator):
        """Int * Int should be valid."""
        ast = parse("""
        facet V(x: Long)
        workflow Test() andThen {
            s = V(x = 3 * 4)
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid, [str(e) for e in result.errors]

    def test_boolean_arithmetic_error(self, validator):
        """Boolean in arithmetic should produce type error."""
        ast = parse("""
        facet V(x: Long)
        workflow Test() andThen {
            s = V(x = true - 1)
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("Boolean" in str(e) and "arithmetic" in str(e) for e in result.errors)

    def test_ref_plus_int_passes(self, validator):
        """Reference + Int should pass (Unknown type, no error)."""
        ast = parse("""
        facet V(x: Long) => (output: Long)
        workflow Test(a: Long) andThen {
            s = V(x = $.a + 1)
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid, [str(e) for e in result.errors]

    def test_step_ref_plus_int_passes(self, validator):
        """Step reference + Int should pass."""
        ast = parse("""
        facet V(x: Long) => (output: Long)
        workflow Test(a: Long) andThen {
            s1 = V(x = $.a)
            s2 = V(x = s1.output + 1)
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid, [str(e) for e in result.errors]

    def test_string_concat_valid(self, validator):
        """String ++ String is always valid (concat, not arithmetic)."""
        ast = parse("""
        facet V(x: String)
        workflow Test() andThen {
            s = V(x = "hello" ++ " " ++ "world")
        }
        """)
        result = validator.validate(ast)
        assert result.is_valid, [str(e) for e in result.errors]

    def test_nested_binary_type_error(self, validator):
        """Nested binary with type error should be caught."""
        ast = parse("""
        facet V(x: Long)
        workflow Test() andThen {
            s = V(x = 1 + 2 * "bad")
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("String" in str(e) for e in result.errors)

    def test_string_multiply_error(self, validator):
        """String * Int should produce type error."""
        ast = parse("""
        facet V(x: Long)
        workflow Test() andThen {
            s = V(x = "abc" * 3)
        }
        """)
        result = validator.validate(ast)
        assert not result.is_valid
        assert any("String" in str(e) for e in result.errors)
