// Copyright 2025 Ralph Lemke
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// AFL v1 Grammar (Lark LALR)

start: _NL* (namespace_block | top_level_decl)*

// Namespace
namespace_block: DOC_COMMENT? "namespace" QNAME "{" _NL* namespace_body "}" _NL*
namespace_body: (uses_decl | facet_decl | event_facet_decl | workflow_decl | implicit_decl | schema_decl)*

uses_decl: ("uses" | "use") QNAME _stmt_end

// Top-level declarations
top_level_decl: facet_decl | event_facet_decl | workflow_decl | implicit_decl

facet_decl: DOC_COMMENT? "facet" facet_sig facet_def_tail? _stmt_end
event_facet_decl: DOC_COMMENT? "event" "facet" facet_sig facet_def_tail? _stmt_end
workflow_decl: DOC_COMMENT? "workflow" facet_sig facet_def_tail? _stmt_end

// Facet signature
facet_sig: IDENT "(" [params] ")" [return_clause] mixin_sig*
return_clause: "=>" "(" [params] ")"

// Parameters (allow newlines)
params: _NL* param (_NL* "," _NL* param)* _NL*
param: IDENT ":" type ("=" expr)?

type: array_type | TYPE_BUILTIN | QNAME
array_type: "[" type "]"

mixin_sig: "with" QNAME "(" [named_args] ")"

// andThen blocks, prompt blocks, and script blocks
facet_def_tail: "andThen" foreach_clause? block more_andthen_block*
              | _NL* "prompt" prompt_block
              | _NL* "script" script_block
more_andthen_block: "andThen" foreach_clause? block

foreach_clause: "foreach" IDENT "in" reference

// Prompt blocks for LLM-based event facets
prompt_block: "{" _NL* prompt_body "}"
prompt_body: (prompt_directive _NL*)*
prompt_directive: "system" STRING -> prompt_system
                | "template" STRING -> prompt_template
                | "model" STRING -> prompt_model

// Script blocks for inline code execution
script_block: STRING
            | _NL* "python" STRING -> script_python

block: "{" _NL* block_body "}" _NL*
block_body: (step_stmt _NL*)* (yield_stmt _NL*)*
step_stmt: IDENT "=" call_expr step_body?
step_body: "andThen" foreach_clause? block

yield_stmt: "yield" call_expr

// Call expressions
call_expr: QNAME "(" [named_args] ")" mixin_call*
mixin_call: "with" QNAME "(" [named_args] ")" ["as" IDENT]

// Arguments (allow newlines)
named_args: _NL* named_arg (_NL* "," _NL* named_arg)* _NL*
named_arg: IDENT "=" _NL* expr

// Expressions
expr: concat_expr
concat_expr: additive_expr ("++" _NL* additive_expr)*
additive_expr: multiplicative_expr (ADD_OP _NL* multiplicative_expr)*
multiplicative_expr: unary_expr (MUL_OP _NL* unary_expr)*
unary_expr: ADD_OP unary_expr | postfix_expr
postfix_expr: atom_expr ("[" expr "]")*
atom_expr: literal | reference | array_literal | map_literal | "(" expr ")"

// Collection literals
array_literal: "[" _NL* (expr (_NL* "," _NL* expr)* _NL*)? "]"
map_literal: "#{" _NL* (map_entry (_NL* "," _NL* map_entry)* _NL*)? "}"
map_entry: (STRING | IDENT) ":" _NL* expr

ADD_OP: "+" | "-"
MUL_OP: "*" | "/" | "%"

reference: INPUT_REF | step_ref
step_ref: IDENT ("." IDENT)+
INPUT_REF: "$." IDENT ("." IDENT)*

literal: STRING | FLOAT | INTEGER | BOOLEAN | NULL

// Schema declarations
schema_decl: DOC_COMMENT? "schema" IDENT "{" _NL* [schema_fields] "}" _stmt_end
schema_fields: schema_field (_NL* "," _NL* schema_field)* _NL*
schema_field: IDENT ":" type

// Implicit declarations
implicit_decl: "implicit" IDENT "=" call_expr _stmt_end

// Statement terminator (newline or semicolon, both optional in many contexts)
_stmt_end: (_NL+ | ";" _NL* | )

// Terminals - order matters for priority
// Keywords and literals must come before IDENT
BOOLEAN.2: "true" | "false"
NULL.2: "null"
TYPE_BUILTIN.2: "String" | "Long" | "Int" | "Double" | "Boolean" | "Json"

STRING: "\"" _STRING_INNER* "\""
_STRING_INNER: /[^"\\]/ | _ESCAPE
_ESCAPE: "\\" /./

FLOAT.2: /[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?/

INTEGER: /[0-9]+/

IDENT: /[A-Za-z_][A-Za-z0-9_]*/
QNAME: IDENT ("." IDENT)*

// Comments
COMMENT: "//" /[^\n]/*
DOC_COMMENT.3: /\/\*\*[\s\S]*?\*\/([ \t]*(\r?\n))*/
BLOCK_COMMENT: "/*" /(.|\n)*?/ "*/"

// Whitespace and newlines
_NL: /(\r?\n)+/
%import common.WS_INLINE
%ignore WS_INLINE
%ignore COMMENT
%ignore BLOCK_COMMENT
