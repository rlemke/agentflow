# Copyright 2025 Ralph Lemke
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""CLI entry point for the AFL runner service.

Usage:
    python -m afl.runtime.runner [options]
"""

import argparse
import logging
import os
import signal

from .service import RunnerConfig, RunnerService


def main() -> None:
    """Run the AFL runner service."""
    parser = argparse.ArgumentParser(
        description="AFL distributed runner service",
        prog="afl-runner",
    )
    parser.add_argument(
        "--config",
        default=None,
        help="Path to AFL config file",
    )
    parser.add_argument(
        "--server-group",
        default="default",
        help="Server group name (default: default)",
    )
    parser.add_argument(
        "--service-name",
        default="afl-runner",
        help="Service name (default: afl-runner)",
    )
    parser.add_argument(
        "--server-name",
        default="",
        help="Server hostname (default: auto-detect)",
    )
    parser.add_argument(
        "--topics",
        nargs="*",
        default=[],
        help="Qualified event facet names to handle, e.g. 'ns.CountDocuments' (default: all with handlers)",
    )
    parser.add_argument(
        "--task-list",
        default="default",
        help="Task list to poll (default: default)",
    )
    parser.add_argument(
        "--poll-interval",
        type=int,
        default=int(os.environ.get("AFL_POLL_INTERVAL_MS", "1000")),
        help="Poll interval in ms (default: AFL_POLL_INTERVAL_MS or 1000)",
    )
    parser.add_argument(
        "--heartbeat-interval",
        type=int,
        default=10000,
        help="Heartbeat interval in ms (default: 10000)",
    )
    parser.add_argument(
        "--max-concurrent",
        type=int,
        default=int(os.environ.get("AFL_MAX_CONCURRENT", "2")),
        help="Max concurrent work items (default: AFL_MAX_CONCURRENT or 2)",
    )
    parser.add_argument(
        "--lock-duration",
        type=int,
        default=60000,
        help="Lock TTL in ms (default: 60000)",
    )
    parser.add_argument(
        "--port",
        type=int,
        default=8080,
        help="HTTP status port (auto-increments if in use; default: 8080)",
    )
    parser.add_argument(
        "--log-level",
        default="INFO",
        choices=["DEBUG", "INFO", "WARNING", "ERROR"],
        help="Log level (default: INFO)",
    )
    parser.add_argument(
        "--log-file",
        default=None,
        metavar="FILE",
        help="Log to file instead of stderr",
    )

    args = parser.parse_args()

    # Configure logging
    log_handlers: list[logging.Handler] = []
    if args.log_file:
        log_handlers.append(logging.FileHandler(args.log_file))
    else:
        log_handlers.append(logging.StreamHandler())

    logging.basicConfig(
        level=getattr(logging, args.log_level),
        format="%(asctime)s %(levelname)s [%(name)s] %(message)s",
        handlers=log_handlers,
    )

    # Load AFL config for MongoDB connection
    from afl.config import load_config
    from afl.runtime import Evaluator, Telemetry
    from afl.runtime.agent import ToolRegistry
    from afl.runtime.mongo_store import MongoStore

    config = load_config(args.config)
    store = MongoStore.from_config(config.mongodb)
    telemetry = Telemetry(enabled=True)
    evaluator = Evaluator(persistence=store, telemetry=telemetry)
    tool_registry = ToolRegistry()

    runner_config = RunnerConfig(
        server_group=args.server_group,
        service_name=args.service_name,
        server_name=args.server_name,
        topics=args.topics,
        task_list=args.task_list,
        poll_interval_ms=args.poll_interval,
        heartbeat_interval_ms=args.heartbeat_interval,
        lock_duration_ms=args.lock_duration,
        max_concurrent=args.max_concurrent,
        http_port=args.port,
    )

    service = RunnerService(
        persistence=store,
        evaluator=evaluator,
        config=runner_config,
        tool_registry=tool_registry,
    )

    # Signal handlers for graceful shutdown
    def handle_signal(signum: int, frame: object) -> None:
        service.stop()

    signal.signal(signal.SIGTERM, handle_signal)
    signal.signal(signal.SIGINT, handle_signal)

    print(f"Starting AFL runner: {runner_config.service_name}")
    print(f"  Server group: {runner_config.server_group}")
    print(f"  Server name:  {runner_config.server_name}")
    print(f"  Task list:    {runner_config.task_list}")
    print(f"  Max workers:  {runner_config.max_concurrent}")
    print(f"  Poll interval: {runner_config.poll_interval_ms}ms")
    print(f"  HTTP port:    {runner_config.http_port} (auto-increments if in use)")

    try:
        service.start()
    except KeyboardInterrupt:
        service.stop()


if __name__ == "__main__":
    main()
