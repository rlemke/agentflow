// Composed Workflows - Demonstrating Facet-Based Composition
//
// These workflows show how to combine multiple facets together:
// - Cache facets for region data
// - Extraction facets for specific features
// - Filter facets for refining results
// - Statistics facets for analysis
// - Visualization facets for output
//
// This demonstrates the power of facet-based workflow composition.

/** Multi-stage composition patterns demonstrating cache, extraction, filtering, statistics, and visualization. */
namespace examples.composed {

    // ==========================================================================
    // PATTERN 1: Cache → Extract → Visualize
    // Basic three-stage pipeline for quick visualization
    // ==========================================================================

    /** Caches a region, extracts bicycle routes, and renders them on a map (three-stage pipeline). */
    workflow VisualizeBicycleRoutes(region: String = "Liechtenstein") => (map_path: String, route_count: Long) andThen {
        // Stage 1: Get cached region data
        cache = osm.geo.Operations.Cache(region = $.region)

        // Stage 2: Extract bicycle routes
        routes = osm.geo.Routes.BicycleRoutes(cache = cache.cache, include_infrastructure = true)

        // Stage 3: Visualize on map
        map = osm.geo.Visualization.RenderMap(
            geojson_path = routes.result.output_path,
            title = "Bicycle Routes",
            color = "#27ae60"
        )

        yield VisualizeBicycleRoutes(map_path = map.result.output_path, route_count = routes.result.feature_count)
    }

    // ==========================================================================
    // PATTERN 2: Cache → Extract → Statistics
    // Analysis pipeline without visualization
    // ==========================================================================

    /** Extracts all parks from a region and computes aggregate statistics without visualization. */
    workflow AnalyzeParks(region: String = "Liechtenstein") => (total_parks: Long, total_area: Double, national: Long, state: Long) andThen {
        // Stage 1: Get cached region data
        cache = osm.geo.Operations.Cache(region = $.region)

        // Stage 2: Extract all parks
        parks = osm.geo.Parks.ExtractParks(cache = cache.cache, park_type = "all")

        // Stage 3: Calculate statistics
        stats = osm.geo.Parks.ParkStatistics(input_path = parks.result.output_path)

        yield AnalyzeParks(
            total_parks = stats.stats.total_parks,
            total_area = stats.stats.total_area_km2,
            national = stats.stats.national_parks,
            state = stats.stats.state_parks
        )
    }

    // ==========================================================================
    // PATTERN 3: Cache → Extract → Filter → Visualize
    // Four-stage pipeline with filtering
    // ==========================================================================

    /** Extracts cities, filters by minimum population, and renders the qualifying cities on a map. */
    workflow LargeCitiesMap(region: String = "Liechtenstein", min_pop: Long = 10000) => (map_path: String, city_count: Long) andThen {
        // Stage 1: Get cached region data
        cache = osm.geo.Operations.Cache(region = $.region)

        // Stage 2: Extract all cities
        cities = osm.geo.Population.Cities(cache = cache.cache, min_population = 0)

        // Stage 3: Filter by population
        large = osm.geo.Population.FilterByPopulation(
            input_path = cities.result.output_path,
            min_population = $.min_pop,
            place_type = "city",
            operator = "gte"
        )

        // Stage 4: Visualize filtered results
        map = osm.geo.Visualization.RenderMap(
            geojson_path = large.result.output_path,
            title = "Large Cities",
            color = "#e74c3c"
        )

        yield LargeCitiesMap(map_path = map.result.output_path, city_count = large.result.feature_count)
    }

    // ==========================================================================
    // PATTERN 4: Cache → Multiple Extractions → Combine Statistics
    // Parallel extraction with aggregated analysis
    // ==========================================================================

    /** Extracts bicycle, hiking, train, and bus routes in parallel and aggregates length statistics. */
    workflow TransportOverview(region: String = "Liechtenstein") => (bicycle_km: Double, hiking_km: Double, train_km: Double, bus_routes: Long) andThen {
        // Stage 1: Get cached region data (shared)
        cache = osm.geo.Operations.Cache(region = $.region)

        // Stage 2: Extract multiple route types (could run in parallel)
        bicycle = osm.geo.Routes.BicycleRoutes(cache = cache.cache, include_infrastructure = false)
        hiking = osm.geo.Routes.HikingTrails(cache = cache.cache, include_infrastructure = false)
        train = osm.geo.Routes.TrainRoutes(cache = cache.cache, include_infrastructure = false)
        bus = osm.geo.Routes.BusRoutes(cache = cache.cache, include_infrastructure = false)

        // Stage 3: Get statistics for each
        bicycle_stats = osm.geo.Routes.RouteStatistics(input_path = bicycle.result.output_path)
        hiking_stats = osm.geo.Routes.RouteStatistics(input_path = hiking.result.output_path)
        train_stats = osm.geo.Routes.RouteStatistics(input_path = train.result.output_path)
        bus_stats = osm.geo.Routes.RouteStatistics(input_path = bus.result.output_path)

        yield TransportOverview(
            bicycle_km = bicycle_stats.stats.total_length_km,
            hiking_km = hiking_stats.stats.total_length_km,
            train_km = train_stats.stats.total_length_km,
            bus_routes = bus_stats.stats.route_count
        )
    }

    // ==========================================================================
    // PATTERN 5: Cache → Extract → Filter → Statistics → Visualize
    // Full five-stage pipeline
    // ==========================================================================

    /** Extracts parks, filters to national parks, computes area statistics, and renders a map. */
    workflow NationalParksAnalysis(region: String = "Liechtenstein") => (map_path: String, park_count: Long, total_area: Double, avg_area: Double) andThen {
        // Stage 1: Get cached region data
        cache = osm.geo.Operations.Cache(region = $.region)

        // Stage 2: Extract all parks
        all_parks = osm.geo.Parks.ExtractParks(cache = cache.cache, park_type = "all")

        // Stage 3: Filter to national parks only
        national = osm.geo.Parks.FilterParksByType(
            input_path = all_parks.result.output_path,
            park_type = "national"
        )

        // Stage 4: Calculate statistics
        stats = osm.geo.Parks.ParkStatistics(input_path = national.result.output_path)

        // Stage 5: Visualize
        map = osm.geo.Visualization.RenderMap(
            geojson_path = national.result.output_path,
            title = "National Parks",
            color = "#2ecc71"
        )

        yield NationalParksAnalysis(
            map_path = map.result.output_path,
            park_count = stats.stats.total_parks,
            total_area = stats.stats.total_area_km2,
            avg_area = stats.stats.total_area_km2
        )
    }

    // ==========================================================================
    // PATTERN 6: Parameterized City Analysis
    // Region and population threshold as parameters
    // ==========================================================================

    /** Extracts cities above a population threshold, computes statistics, and renders a map. */
    workflow CityAnalysis(region: String = "Liechtenstein", min_population: Long = 100000) => (map_path: String, large_cities: Long, total_pop: Long) andThen {
        // Stage 1: Get cached region data
        cache = osm.geo.Operations.Cache(region = $.region)

        // Stage 2: Extract cities with population
        cities = osm.geo.Population.Cities(cache = cache.cache, min_population = $.min_population)

        // Stage 3: Get statistics
        stats = osm.geo.Population.PopulationStatistics(
            input_path = cities.result.output_path,
            place_type = "city"
        )

        // Stage 4: Visualize
        map = osm.geo.Visualization.RenderMap(
            geojson_path = cities.result.output_path,
            title = "Cities",
            color = "#3498db"
        )

        yield CityAnalysis(
            map_path = map.result.output_path,
            large_cities = stats.stats.total_places,
            total_pop = stats.stats.total_population
        )
    }

    // ==========================================================================
    // PATTERN 7: Multi-Layer Visualization
    // Combining multiple extractions into one visual output
    // ==========================================================================

    /** Extracts bicycle and hiking routes and renders the bicycle layer on a map. */
    workflow TransportMap(region: String = "Liechtenstein") => (map_path: String) andThen {
        // Stage 1: Get cached region data
        cache = osm.geo.Operations.Cache(region = $.region)

        // Stage 2: Extract different transport types
        bicycle = osm.geo.Routes.BicycleRoutes(cache = cache.cache, include_infrastructure = false)
        hiking = osm.geo.Routes.HikingTrails(cache = cache.cache, include_infrastructure = false)

        // Stage 3: Create individual maps (could be combined with RenderLayers if arrays were supported)
        bicycle_map = osm.geo.Visualization.RenderMap(
            geojson_path = bicycle.result.output_path,
            title = "Bicycle Routes",
            color = "#27ae60"
        )

        yield TransportMap(map_path = bicycle_map.result.output_path)
    }

    // ==========================================================================
    // PATTERN 8: Boundary Analysis Pipeline
    // Administrative boundary extraction with filtering
    // ==========================================================================

    /** Extracts state-level administrative boundaries and renders them on a map with counts. */
    workflow StateBoundariesWithStats(region: String = "Liechtenstein") => (map_path: String, state_count: Long) andThen {
        // Stage 1: Get cached region data
        cache = osm.geo.Operations.Cache(region = $.region)

        // Stage 2: Extract state-level boundaries
        boundaries = osm.geo.Boundaries.StateBoundaries(cache = cache.cache)

        // Stage 3: Visualize
        map = osm.geo.Visualization.RenderMap(
            geojson_path = boundaries.result.output_path,
            title = "State Boundaries",
            color = "#9b59b6"
        )

        yield StateBoundariesWithStats(
            map_path = map.result.output_path,
            state_count = boundaries.result.feature_count
        )
    }

    // ==========================================================================
    // PATTERN 9: POI Discovery Pipeline
    // Find and visualize points of interest
    // ==========================================================================

    /** Discovers cities, towns, and villages in a region and renders cities on a map. */
    workflow DiscoverCitiesAndTowns(region: String = "Liechtenstein") => (map_path: String, cities: Long, towns: Long, villages: Long) andThen {
        // Stage 1: Get cached region data
        cache = osm.geo.Operations.Cache(region = $.region)

        // Stage 2: Extract settlements at different levels
        city_data = osm.geo.POIs.Cities(cache = cache.cache)
        town_data = osm.geo.POIs.Towns(cache = cache.cache)
        village_data = osm.geo.POIs.Villages(cache = cache.cache)

        // Stage 3: Visualize cities (largest settlements)
        map = osm.geo.Visualization.RenderMap(
            geojson_path = city_data.cities.path,
            title = "Cities",
            color = "#e74c3c"
        )

        yield DiscoverCitiesAndTowns(
            map_path = map.result.output_path,
            cities = city_data.cities.size,
            towns = town_data.towns.size,
            villages = village_data.villages.size
        )
    }

    // ==========================================================================
    // PATTERN 10: Complete Regional Analysis
    // Comprehensive analysis combining multiple feature types
    // ==========================================================================

    /** Comprehensive analysis extracting parks, routes, and cities with statistics and a park map overlay. */
    workflow RegionalAnalysis(region: String = "Liechtenstein") => (parks_count: Long, parks_area: Double, routes_km: Double, cities_count: Long, map_path: String) andThen {
        // Stage 1: Get cached region data (shared across all extractions)
        cache = osm.geo.Operations.Cache(region = $.region)

        // Stage 2: Extract multiple feature types
        parks = osm.geo.Parks.ExtractParks(cache = cache.cache, park_type = "all")
        routes = osm.geo.Routes.BicycleRoutes(cache = cache.cache, include_infrastructure = false)
        cities = osm.geo.Population.Cities(cache = cache.cache, min_population = 0)

        // Stage 3: Calculate statistics for each
        park_stats = osm.geo.Parks.ParkStatistics(input_path = parks.result.output_path)
        route_stats = osm.geo.Routes.RouteStatistics(input_path = routes.result.output_path)
        city_stats = osm.geo.Population.PopulationStatistics(
            input_path = cities.result.output_path,
            place_type = "city"
        )

        // Stage 4: Visualize primary layer (parks)
        map = osm.geo.Visualization.RenderMap(
            geojson_path = parks.result.output_path,
            title = "Regional Overview - Parks",
            color = "#2ecc71"
        )

        yield RegionalAnalysis(
            parks_count = park_stats.stats.total_parks,
            parks_area = park_stats.stats.total_area_km2,
            routes_km = route_stats.stats.total_length_km,
            cities_count = city_stats.stats.total_places,
            map_path = map.result.output_path
        )
    }

    // ==========================================================================
    // PATTERN 11: Cache → Validate → Summary
    // Data quality validation pipeline
    // ==========================================================================

    /** Validates a cached region's OSM data and produces a summary of valid/invalid entries. */
    workflow ValidateAndSummarize(region: String = "Liechtenstein", output_dir: String = "/tmp") => (total: Long, valid: Long, invalid: Long, output_path: String) andThen {
        // Stage 1: Get cached region data
        cache = osm.geo.Operations.Cache(region = $.region)

        // Stage 2: Run full validation on the cache
        validation = osm.geo.Operations.Validation.ValidateCache(
            cache = cache.cache,
            output_dir = $.output_dir,
            use_hdfs = false
        )

        // Stage 3: Compute summary statistics from validation output
        summary = osm.geo.Operations.Validation.ValidationSummary(
            input_path = validation.result.output_path
        )

        yield ValidateAndSummarize(
            total = summary.stats.total_entries,
            valid = summary.stats.valid_entries,
            invalid = summary.stats.invalid_entries,
            output_path = validation.result.output_path
        )
    }

    // ==========================================================================
    // PATTERN 12: Cache → Local Verify → Summary
    // Standalone local PBF quality analysis via OSMOSE verifier
    // ==========================================================================

    /** Runs OSMOSE local verification on a region's PBF and summarizes geometry/tag/reference issues. */
    workflow OsmoseQualityCheck(
        region: String = "Liechtenstein",
        output_dir: String = "/tmp"
    ) => (
        total_issues: Long,
        geometry_issues: Long,
        tag_issues: Long,
        reference_issues: Long,
        tag_coverage_pct: Double,
        output_path: String
    ) andThen {
        // Stage 1: Get cached region data
        cache = osm.geo.Operations.Cache(region = $.region)

        // Stage 2: Run full local verification on the PBF
        verify = osm.geo.Operations.OSMOSE.VerifyAll(
            cache = cache.cache,
            output_dir = $.output_dir
        )

        // Stage 3: Compute summary statistics from verification output
        summary = osm.geo.Operations.OSMOSE.ComputeVerifySummary(
            input_path = verify.result.output_path
        )

        yield OsmoseQualityCheck(
            total_issues = summary.summary.total_issues,
            geometry_issues = summary.summary.geometry_issues,
            tag_issues = summary.summary.tag_issues,
            reference_issues = summary.summary.reference_issues,
            tag_coverage_pct = summary.summary.tag_coverage_pct,
            output_path = verify.result.output_path
        )
    }

    // ==========================================================================
    // PATTERN 13: GTFS Transit Analysis
    // Download feed → parallel extract stops + routes → statistics
    // ==========================================================================

    /** Downloads a GTFS feed, extracts stops and routes in parallel, and computes transit statistics. */
    workflow TransitAnalysis(
        gtfs_url: String
    ) => (
        agency_name: String,
        stop_count: Long,
        route_count: Long,
        trip_count: Long,
        has_shapes: Boolean,
        stops_path: String,
        routes_path: String
    ) andThen {
        // Stage 1: Download and cache the GTFS feed
        dl = osm.geo.Transit.GTFS.DownloadFeed(url = $.gtfs_url)

        // Stage 2: Extract stops and routes in parallel
        stops = osm.geo.Transit.GTFS.ExtractStops(feed = dl.feed)
        routes = osm.geo.Transit.GTFS.ExtractRoutes(feed = dl.feed)

        // Stage 3: Compute aggregate statistics
        stats = osm.geo.Transit.GTFS.TransitStatistics(feed = dl.feed)

        yield TransitAnalysis(
            agency_name = stats.stats.agency_name,
            stop_count = stats.stats.stop_count,
            route_count = stats.stats.route_count,
            trip_count = stats.stats.trip_count,
            has_shapes = stats.stats.has_shapes,
            stops_path = stops.result.output_path,
            routes_path = routes.result.output_path
        )
    }

    // ==========================================================================
    // PATTERN 14: GTFS Transit Accessibility
    // OSM cache + GTFS feed → extract buildings + stops → accessibility → gaps
    // ==========================================================================

    /** Measures transit accessibility by computing walk-distance bands and detecting coverage gaps. */
    workflow TransitAccessibility(
        gtfs_url: String,
        region: String = "Liechtenstein"
    ) => (
        pct_within_400m: Double,
        pct_within_800m: Double,
        coverage_pct: Double,
        gap_cells: Long,
        accessibility_path: String,
        coverage_path: String
    ) andThen {
        // Stage 1: Get OSM cache and download GTFS feed in parallel
        cache = osm.geo.Operations.Cache(region = $.region)
        dl = osm.geo.Transit.GTFS.DownloadFeed(url = $.gtfs_url)

        // Stage 2: Extract buildings from OSM and stops from GTFS in parallel
        buildings = osm.geo.Buildings.ExtractBuildings(cache = cache.cache)
        stops = osm.geo.Transit.GTFS.ExtractStops(feed = dl.feed)

        // Stage 3: Compute walk-distance accessibility bands
        access = osm.geo.Transit.GTFS.StopAccessibility(
            osm_geojson_path = buildings.result.output_path,
            stops_geojson_path = stops.result.output_path,
            walk_threshold_m = 400
        )

        // Stage 4: Detect coverage gaps
        gaps = osm.geo.Transit.GTFS.CoverageGaps(
            stops_geojson_path = stops.result.output_path,
            osm_geojson_path = buildings.result.output_path,
            cell_size_m = 500
        )

        yield TransitAccessibility(
            pct_within_400m = access.result.pct_within_400m,
            pct_within_800m = access.result.pct_within_800m,
            coverage_pct = gaps.result.coverage_pct,
            gap_cells = gaps.result.gap_cells,
            accessibility_path = access.result.output_path,
            coverage_path = gaps.result.output_path
        )
    }

    // ==========================================================================
    // PATTERN 15: Low-Zoom Road Infrastructure Builder
    // Cache → Build GraphHopper → Build Zoom Layers (minZoom per edge z2–z7)
    // ==========================================================================

    /** Builds a routing graph and assigns minimum zoom levels to road edges for low-zoom tile rendering. */
    workflow RoadZoomBuilder(
        region: String = "Liechtenstein",
        output_dir: String = "/tmp/zoom-builder",
        max_concurrent: Long = 16
    ) => (
        total_edges: Long,
        selected_edges: Long,
        zoom_distribution: String,
        csv_path: String,
        metrics_path: String
    ) andThen {
        // Stage 1: Get cached region data
        cache = osm.geo.Operations.Cache(region = $.region)

        // Stage 2: Build GraphHopper graph for routing
        graph = osm.geo.Operations.GraphHopper.BuildGraph(cache = cache.cache)

        // Stage 3: Run full zoom builder pipeline
        zoom = osm.geo.Roads.ZoomBuilder.BuildZoomLayers(
            cache = cache.cache,
            graph = graph.graph,
            output_dir = $.output_dir,
            max_concurrent = $.max_concurrent
        )

        yield RoadZoomBuilder(
            total_edges = zoom.result.total_logical_edges,
            selected_edges = zoom.result.selected_edges,
            zoom_distribution = zoom.result.zoom_distribution,
            csv_path = zoom.result.csv_path,
            metrics_path = zoom.result.metrics_path
        )
    }
}
